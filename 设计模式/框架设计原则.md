### 模块分包原则
- 复用度   
包中的类应有同样的重用可能性。  
紧密联系的类应放在一起。  
对于一个变化因子，包中的类应全改或全不改。  
变化应在包内终止，而不应传播到包外。  
发布的粒度和复用度相同。
- 稳定度  
被依赖的包应该总比依赖者稳定。  
不要让一个稳定的包依赖一个不稳定的包。  
单项依赖，无环依赖。
- 抽象度  
越稳定的包应该越抽象。  
稳定的包如果不够抽象，将导致可扩展性极差。  
抽象的包不稳定将导致其依赖者跟随变化。  


### 框架扩展原则
- 微核 + 插件体系  
	微核不能绑定任何具体功能实现。所有的功能都是插件完成的。微核只做生命周期管理。（想想spring）
	常见微核：OSGI（如eclipse），IOC（如spring）， SPI（如jdk1.6+自带的）
- 平等对待第三方
	- 微核 + 插件体系 做的好那么就是平等对待了。
	- 自动装配，装配逻辑由扩展点互助完成，杜绝硬编码的桥接和中间代码。
	- 层级扩展，由大的扩展点加载小的扩展点。
- 外置生命周期
	- 尽量引用外部对象实例，而不是类元。
	- 尽量使用IOC，而不是静态工厂调用
- 最少化概念模型
	- 简化模型
- 一致化数据模型
	- 所有数据转化成同一的URL数据模型。
	URL模型好像一个总线。所有的动作从URL模型获取参数。
	
### 模型划分原则
- 服务域  
	产品的主要功能入口，同时负责实体域和会话域的生命周期管理。  
	无状态，天生线程安全。一般都是单例的。
	如spring的beanFactory。
	Dubbo的protocol,负责Invoker的生命周期管理  
- 实体域  
	表示你要操作的对象模型，不管什么产品，总有一个核心概念，大家都围着你转。   
	通常设计成不变类，所有属性只读，或者整个类引用替换，所以是线程安全的。   
	如spring的bean 
	Dubbo的Invoker。Dubbo的核心模型。 其他模型都向他靠，或转换成他。代表一个可执行实体。  
- 会话域  
	表示每次操作瞬时状态，操作时创建，操作后销毁。    
	保持所有可变状态，且只在线程栈内使用，只在栈内生存，不存在竞争，所以是线程安全的。
	如spring的context。
	Dubbo的Invocation，持有调用过程中的变量，如方法名，参数等。  
	
- 好处
	- 结构清晰，可直接套用
	- 充血模型，数据和行为绑在一起。（贫血模型，数据和行为剥离）
	- 可变状态和不可变状态分离。可变状态集中。服务域和实体域是不可变状态，会话域是可变状态。
	- 所有领域线程安全，不需要加锁。业务代码不需要关注线程安全问题，线程安全由框架保证。 
	

### 接口分离原则
- API
	user使用的。  
	声明式API
- SPI
	framework使用的。  
	过程式SPI
- API与SPI分离
- API区分命令与查询。
接口不要有副作用，应该是幂等的。  
- 保持接口的对称性，比如有add就应该有remove。  

- 接口加方法：增加子接口，通过instanceOf识别
- 包名调整：让旧接口继承调整后的接口。

### 组件协作原则
- 管道
	- 组合行为
	- 主功能以截面实现
	- 比如，servlet
- 派发
	- 策略行为
	- 主功能以事件实现
	- 比如，swing
- 分布
	- 在行为交互为主的系统是适用
	- 状态通过行为传递
- 共享
	- 在以管理状态为主的系统中适用
	- 状态通过仓库共享
	

### 功能演进原则
- 开放原则
	- 对扩展开放
	- 对修改关闭
	- 软件质量的下降，来源于修改
- 增量扩展
- 如果再高阶模块和低阶模块上都可以实现的功能，应优选在高阶模块实现。

从下向上复用原则

消费者-----代理----集群-------filter --- 协议----服务器真正实现类


