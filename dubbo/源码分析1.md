### SPI
Dubbo采用微内核+插件体系。设计优雅，可扩展性强。  
微内核+插件体系的实现是基于SPI机制。（service provider interface）  
框架定义服务标准接口，使用者可以自己扩展服务实现。  

1, Dubbo定义了`@SPI`注解  
对于打了@spi注解的接口，dubbo会从以下目录依次查找实现。
META-INF/dubbo/internal/ //dubbo 内部实现的各种扩展都放在了这个目录  
了
META-INF/dubbo/  
META-INF/services/  

2, ExtensionLoader是SPI加载器。
`com.alibaba.dubbo.common.extension.ExtensionLoader#loadExtensionClasses`

### 服务暴露
关注`com.alibaba.dubbo.config.spring.ServiceBean`  
管理服务的生命周期。  

1. setApplicationContext 设置容器 applicationContext
2. afterPropertiesSet 回调InitializingBean 的 afterPropertiesSet  
3. onApplicationEvent spring的最后一步 finishRefresh 会触发 ContextRefreshedEvent 事件，而 ServiceBean
实现了 ApplicationListener 接口监听了此事件， 而在之前一步实例化的
ServiceBean 注 册 了 这 个 事 件 ， 所 以 ServiceBean 的
onApplicationEvent(ApplicationEvent event)方法被触发， 在这个方法中触
发了 export 方法来暴露服务。  
4. destroy 服务下线  

#### export
看一下export具体是怎么实现的  

1. ServiceBean实现了ApplicationListener接口，监听容器加载完成事件ContextRefreshedEvent。  
开始export()  
2. com.alibaba.dubbo.config.ServiceConfig#export()会判断是否是延迟暴露。  
是则起一个守护线程Thread.sleep(delay)后暴露，否则直接暴露。
3. com.alibaba.dubbo.config.ServiceConfig#doExport().装载注册中心监控中心等
4. com.alibaba.dubbo.config.ServiceConfig#doExportUrls,  
执行loadRegistries()遍历注册中心，根据注册中心、Dubbo版本、Pid等生成要发布的URL;
URL示例： zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=ordercenter_serviceImpl
&dubbo=2.8.4&pid=15836&registry=zookeeper&timestamp=1484018365125  
遍历所有协议，遍历服务协议，为每个协议执行doExportUrlsFor1Protocol()
5. com.alibaba.dubbo.config.ServiceConfig#doExportUrlsFor1Protocol
	
	```
	Invoker<?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);
	Exporter<?> exporter = protocol.export(invoker);
	```
	关键的两句，  

	1. 将具体的服务转换成invoker，  
	ref是接口实现类引用，interfaceClass是接口，url是组装的服务url。  
	转换使用JavassistProxyFactory或者JdkProxyFactory中一个。
	2. 然后将invoker转换成exporter。  
	转化过程使用众多协议中的一个，DubboProtocol、hessionProtocol、redisProtocol等等

6. 比如DubboProtocol   
	export() -> openServer() ->createServer()  
	createServer()中通过`server = Exchangers.bind(url, requestHandler);`
	代码转到`com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchanger#bind`  
	最终转到创建NettyServer。  
	

### 服务引用
关注`com.alibaba.dubbo.config.spring.ReferenceBean`  
ReferenceBean实现了FactoryBean接口，spring的bean工厂在获取的bean的时候会判断下是不是FactoryBean的实例，如果是调factoryBean.getObject()返回，否则返回bean。  
我们使用时并不是想要ReferenceBean这个实例，而是希望通过这个实例获取对应的代理，通过代理调用远程服务。  
所以在factoryBean.getObject()中封装了复杂实现，使我们可以拿到代理对象。  

1. ReferenceBean实现InitializingBean接口，spring回调afterPropertiesSet()
2. getObject()
3. 检查dubbo配置，创建代理。
4. 向注册中心订阅服务。
5. 返回代理对象。


### dubbo的spring配置是如何解析的？
以`META-INF/spring/dubbo-demo-provider.xml`为例。  

```
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
	http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd">
	
	<bean id="demoService" class="com.alibaba.dubbo.demo.provider.DemoServiceImpl" />
	
	<dubbo:service interface="com.alibaba.dubbo.demo.DemoService" ref="demoService" />
	
</beans>
```
其中的`dubbo:service `是自定义的扩展schema，他是如何被spring解析的呢？  
原理：spring支持自定义扩展schema。  
具体原理：spring默认会加载两个文件：这两个文件的地址必须是META-INF/spring.handlers和META-INF/spring.schemas。  
对应的dubbo，可在dubbo-config-spring下找到。

META-INF/spring.schemas的内容：
`http\://code.alibabatech.com/schema/dubbo/dubbo.xsd=META-INF/dubbo.xsd`
放的是自己定义的xsd文件位置。 

META-INF/spring.handlers的内容：
```
http\://code.alibabatech.com/schema/dubbo=com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler
```
这个类DubboNamespaceHandler是将xsd中定义的标签，找到对应的解析器。

handler要继承spring提供的NamespaceHandlerSupport。  
DubboBeanDefinitionParser要实现spring提供的BeanDefinitionParser。  

这样，spring就可以找到xsd以及对应的解析器。  
最后在spring的xml中使用是，引入即可。


 

